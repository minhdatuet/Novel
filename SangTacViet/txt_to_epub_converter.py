#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
TXT to EPUB Converter
Convert file TXT th√†nh file EPUB v·ªõi c·∫•u tr√∫c ƒë·∫πp
"""

import os
import re
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from single_file_epub_creator import create_epub_from_chapters

class TxtToEpubConverter:
    """GUI converter t·ª´ TXT sang EPUB"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("üìö TXT to EPUB Converter")
        self.root.geometry("800x600")
        self.root.resizable(True, True)
        
        # Variables
        self.input_file_var = tk.StringVar()
        self.output_dir_var = tk.StringVar(value=".")
        self.book_title_var = tk.StringVar()
        self.author_var = tk.StringVar(value="T√°c gi·∫£ kh√¥ng r√µ")
        self.language_var = tk.StringVar(value="vi")
        self.chapter_pattern_var = tk.StringVar(value="CH∆Ø∆†NG")
        
        self.setup_ui()
        self.scan_txt_files()
        
    def setup_ui(self):
        """T·∫°o giao di·ªán"""
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        
        row = 0
        
        # Title
        title_label = ttk.Label(main_frame, text="üìö TXT to EPUB Converter", 
                               font=('Helvetica', 16, 'bold'))
        title_label.grid(row=row, column=0, columnspan=3, pady=(0, 20))
        row += 1
        
        # Input file selection
        ttk.Label(main_frame, text="üìÑ File TXT:", font=('Helvetica', 10, 'bold')).grid(
            row=row, column=0, sticky=tk.W, pady=(0, 5))
        row += 1
        
        input_frame = ttk.Frame(main_frame)
        input_frame.grid(row=row, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 10))
        input_frame.columnconfigure(0, weight=1)
        
        self.input_entry = ttk.Entry(input_frame, textvariable=self.input_file_var, font=('Consolas', 9))
        self.input_entry.grid(row=0, column=0, sticky=(tk.W, tk.E), padx=(0, 5))
        
        ttk.Button(input_frame, text="üìÇ Browse", command=self.browse_input_file, width=10).grid(row=0, column=1)
        row += 1
        
        # Book info frame
        info_frame = ttk.LabelFrame(main_frame, text="üìñ Th√¥ng tin s√°ch", padding="10")
        info_frame.grid(row=row, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 10))
        info_frame.columnconfigure(1, weight=1)
        
        # Book title
        ttk.Label(info_frame, text="T√™n s√°ch:").grid(row=0, column=0, sticky=tk.W, padx=(0, 10))
        ttk.Entry(info_frame, textvariable=self.book_title_var, font=('Consolas', 9)).grid(
            row=0, column=1, sticky=(tk.W, tk.E), pady=(0, 5))
        
        # Author
        ttk.Label(info_frame, text="T√°c gi·∫£:").grid(row=1, column=0, sticky=tk.W, padx=(0, 10))
        ttk.Entry(info_frame, textvariable=self.author_var, font=('Consolas', 9)).grid(
            row=1, column=1, sticky=(tk.W, tk.E), pady=(0, 5))
        
        # Language
        ttk.Label(info_frame, text="Ng√¥n ng·ªØ:").grid(row=2, column=0, sticky=tk.W, padx=(0, 10))
        language_frame = ttk.Frame(info_frame)
        language_frame.grid(row=2, column=1, sticky=tk.W, pady=(0, 5))
        
        ttk.Radiobutton(language_frame, text="üáªüá≥ Ti·∫øng Vi·ªát", 
                       variable=self.language_var, value="vi").grid(row=0, column=0, padx=(0, 20))
        ttk.Radiobutton(language_frame, text="üá®üá≥ Ti·∫øng Trung", 
                       variable=self.language_var, value="zh").grid(row=0, column=1)
        
        row += 1
        
        # Chapter detection frame
        chapter_frame = ttk.LabelFrame(main_frame, text="üìë Ph√°t hi·ªán ch∆∞∆°ng", padding="10")
        chapter_frame.grid(row=row, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 10))
        chapter_frame.columnconfigure(1, weight=1)
        
        ttk.Label(chapter_frame, text="Pattern ch∆∞∆°ng:").grid(row=0, column=0, sticky=tk.W, padx=(0, 10))
        ttk.Entry(chapter_frame, textvariable=self.chapter_pattern_var, font=('Consolas', 9)).grid(
            row=0, column=1, sticky=(tk.W, tk.E), padx=(0, 5))
        
        ttk.Button(chapter_frame, text="üîç Preview", command=self.preview_chapters, width=10).grid(row=0, column=2)
        
        row += 1
        
        # Output directory
        ttk.Label(main_frame, text="üìÅ Th∆∞ m·ª•c output:", font=('Helvetica', 10, 'bold')).grid(
            row=row, column=0, sticky=tk.W, pady=(10, 5))
        row += 1
        
        output_frame = ttk.Frame(main_frame)
        output_frame.grid(row=row, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 10))
        output_frame.columnconfigure(0, weight=1)
        
        self.output_entry = ttk.Entry(output_frame, textvariable=self.output_dir_var, font=('Consolas', 9))
        self.output_entry.grid(row=0, column=0, sticky=(tk.W, tk.E), padx=(0, 5))
        
        ttk.Button(output_frame, text="üìÇ Browse", command=self.browse_output_dir, width=10).grid(row=0, column=1)
        row += 1
        
        # Control buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=row, column=0, columnspan=3, pady=(10, 0))
        
        self.convert_btn = ttk.Button(button_frame, text="üöÄ Convert to EPUB", 
                                     command=self.convert_to_epub, style='Accent.TButton')
        self.convert_btn.grid(row=0, column=0, padx=(0, 10))
        
        ttk.Button(button_frame, text="üóÇÔ∏è M·ªü th∆∞ m·ª•c output", 
                  command=self.open_output_folder).grid(row=0, column=1, padx=(0, 10))
        
        row += 1
        
        # Log area
        log_frame = ttk.LabelFrame(main_frame, text="üìã Log", padding="10")
        log_frame.grid(row=row, column=0, columnspan=3, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(10, 0))
        log_frame.columnconfigure(0, weight=1)
        log_frame.rowconfigure(0, weight=1)
        main_frame.rowconfigure(row, weight=1)
        
        from tkinter import scrolledtext
        self.log_text = scrolledtext.ScrolledText(log_frame, height=12, font=('Consolas', 9))
        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
    def scan_txt_files(self):
        """Scan v√† hi·ªÉn th·ªã c√°c file TXT c√≥ s·∫µn"""
        self.log("üîç ƒêang t√¨m ki·∫øm file TXT trong th∆∞ m·ª•c hi·ªán t·∫°i...")
        
        # T√¨m file TXT g·∫ßn ƒë√¢y nh·∫•t
        txt_files = []
        for root_dir, dirs, files in os.walk(".."):
            for file in files:
                if file.endswith('.txt') and 'vietnamese' in file.lower():
                    full_path = os.path.join(root_dir, file)
                    txt_files.append(full_path)
        
        if txt_files:
            # L·∫•y file m·ªõi nh·∫•t
            latest_file = max(txt_files, key=os.path.getmtime)
            self.input_file_var.set(latest_file)
            self.log(f"üìÑ T√¨m th·∫•y file TXT: {os.path.basename(latest_file)}")
            
            # T·ª± ƒë·ªông ƒëi·ªÅn t√™n s√°ch
            book_name = os.path.basename(latest_file).replace('_vietnamese', '').replace('.txt', '')
            # L√†m s·∫°ch t√™n
            book_name = re.sub(r'_\d+$', '', book_name)  # B·ªè timestamp
            self.book_title_var.set(book_name)
            self.log(f"üìö T√™n s√°ch t·ª± ƒë·ªông: {book_name}")
        else:
            self.log("‚ùå Kh√¥ng t√¨m th·∫•y file TXT n√†o")
    
    def browse_input_file(self):
        """Browse ch·ªçn file TXT input"""
        file_path = filedialog.askopenfilename(
            title="Ch·ªçn file TXT",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        if file_path:
            self.input_file_var.set(file_path)
            
            # T·ª± ƒë·ªông ƒëi·ªÅn t√™n s√°ch t·ª´ t√™n file
            if not self.book_title_var.get():
                book_name = os.path.basename(file_path).replace('.txt', '')
                book_name = re.sub(r'_vietnamese|_chinese', '', book_name)
                book_name = re.sub(r'_\d+$', '', book_name)
                self.book_title_var.set(book_name)
    
    def browse_output_dir(self):
        """Browse ch·ªçn th∆∞ m·ª•c output"""
        directory = filedialog.askdirectory(initialdir=self.output_dir_var.get())
        if directory:
            self.output_dir_var.set(directory)
    
    def preview_chapters(self):
        """Preview c√°ch ph√°t hi·ªán ch∆∞∆°ng"""
        input_file = self.input_file_var.get()
        if not input_file or not os.path.exists(input_file):
            messagebox.showerror("L·ªói", "Vui l√≤ng ch·ªçn file TXT h·ª£p l·ªá!")
            return
        
        try:
            chapters = self._parse_chapters_from_txt(input_file)
            if chapters:
                preview_text = f"üîç T√¨m th·∫•y {len(chapters)} ch∆∞∆°ng:\n\n"
                for i, chapter in enumerate(chapters[:10], 1):  # Show first 10
                    preview_text += f"{i}. {chapter['title'][:60]}...\n"
                if len(chapters) > 10:
                    preview_text += f"\n... v√† {len(chapters) - 10} ch∆∞∆°ng kh√°c"
                
                messagebox.showinfo("Preview Chapters", preview_text)
                self.log(f"‚úÖ Preview: T√¨m th·∫•y {len(chapters)} ch∆∞∆°ng")
            else:
                messagebox.showwarning("C·∫£nh b√°o", "Kh√¥ng t√¨m th·∫•y ch∆∞∆°ng n√†o v·ªõi pattern hi·ªán t·∫°i!")
                self.log("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y ch∆∞∆°ng n√†o")
        except Exception as e:
            messagebox.showerror("L·ªói", f"L·ªói khi preview: {str(e)}")
            self.log(f"‚ùå L·ªói preview: {str(e)}")
    
    def convert_to_epub(self):
        """Convert TXT sang EPUB"""
        input_file = self.input_file_var.get()
        if not input_file or not os.path.exists(input_file):
            messagebox.showerror("L·ªói", "Vui l√≤ng ch·ªçn file TXT h·ª£p l·ªá!")
            return
        
        book_title = self.book_title_var.get().strip()
        if not book_title:
            messagebox.showerror("L·ªói", "Vui l√≤ng nh·∫≠p t√™n s√°ch!")
            return
        
        try:
            self.log(f"üöÄ B·∫Øt ƒë·∫ßu convert: {os.path.basename(input_file)}")
            
            # Parse chapters
            chapters = self._parse_chapters_from_txt(input_file)
            if not chapters:
                self.log("‚ùå Kh√¥ng t√¨m th·∫•y ch∆∞∆°ng n√†o!")
                messagebox.showerror("L·ªói", "Kh√¥ng t√¨m th·∫•y ch∆∞∆°ng n√†o v·ªõi pattern hi·ªán t·∫°i!")
                return
            
            self.log(f"üìë ƒê√£ parse {len(chapters)} ch∆∞∆°ng")
            
            # T·∫°o EPUB
            output_dir = self.output_dir_var.get()
            epub_file = create_epub_from_chapters(
                book_title=book_title,
                chapters=chapters,
                output_dir=output_dir,
                author=self.author_var.get(),
                language=self.language_var.get()
            )
            
            self.log(f"üéâ HO√ÄN TH√ÄNH!")
            self.log(f"üìö File EPUB: {os.path.basename(epub_file)}")
            self.log(f"üìÅ ƒê∆∞·ªùng d·∫´n: {epub_file}")
            
            messagebox.showinfo("Th√†nh c√¥ng", 
                               f"Convert th√†nh c√¥ng!\\n\\n"
                               f"File EPUB: {os.path.basename(epub_file)}\\n"
                               f"S·ªë ch∆∞∆°ng: {len(chapters)}")
        
        except Exception as e:
            self.log(f"‚ùå L·ªói: {str(e)}")
            messagebox.showerror("L·ªói", f"Convert th·∫•t b·∫°i: {str(e)}")
    
    def _parse_chapters_from_txt(self, file_path):
        """Parse chapters t·ª´ file TXT"""
        chapters = []
        chapter_pattern = self.chapter_pattern_var.get().strip()
        
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # T√¨m v·ªã tr√≠ k·∫øt th√∫c m·ª•c l·ª•c ƒë·ªÉ b·ªè qua ph·∫ßn m·ª•c l·ª•c
        lines = content.split('\n')
        content_start_idx = 0
        
        # T√¨m d√≤ng "================" ƒë·ªÉ x√°c ƒë·ªãnh k·∫øt th√∫c header
        for i, line in enumerate(lines):
            if '================' in line and i > 5:  # Sau header info
                content_start_idx = i + 1
                break
        
        # T√¨m th√™m ƒë·ªÉ b·ªè qua m·ª•c l·ª•c (t√¨m d√≤ng ƒë·∫ßu ti√™n c√≥ n·ªôi dung th·∫≠t)
        for i in range(content_start_idx, len(lines)):
            line = lines[i].strip()
            if line and not line.startswith('Ch∆∞∆°ng') and not line.startswith('üìñ') and not line.startswith('---'):
                if len(line) > 50 and 'Á¨¨' not in line and 'M·ª§C L·ª§C' not in line:
                    content_start_idx = i
                    break
        
        # S·ª≠ d·ª•ng ch·ªâ ph·∫ßn n·ªôi dung th·∫≠t (b·ªè qua m·ª•c l·ª•c)
        actual_content_lines = lines[content_start_idx:]
        
        # T√¨m pattern ch∆∞∆°ng trong n·ªôi dung th·∫≠t
        patterns = [
            r'^Th·ª©\s+(\d+)\s+ch∆∞∆°ng\s*(.*)$',           # Th·ª© 1 ch∆∞∆°ng Title
            r'^Á¨¨(\d+)Á´†\s*(.*)$',                        # Á¨¨1Á´† Title  
            rf'^{chapter_pattern}\s+(\d+)[:\s]*(.*)$',   # CH∆Ø∆†NG 1: Title
            rf'^{chapter_pattern}\s+(\d+)(.*)$',         # CH∆Ø∆†NG 1 Title
            rf'^Ch\w*\s+(\d+)[:\s]*(.*)$',              # Chapter 1: Title
        ]
        
        current_chapter = None
        current_content = []
        chapter_number = 0
        in_chapter_content = False
        
        for line in actual_content_lines:
            line = line.strip()
            if not line:
                if current_content and in_chapter_content:
                    current_content.append('')
                continue
            
            # Check if this is a chapter header
            is_chapter_header = False
            for pattern in patterns:
                match = re.match(pattern, line, re.IGNORECASE)
                if match:
                    # Save previous chapter
                    if current_chapter and current_content:
                        chapters.append({
                            'number': current_chapter['number'],
                            'title': current_chapter['title'],
                            'content': '\n'.join(current_content).strip(),
                            'chapter_id': f'{current_chapter["number"]:03d}'
                        })
                    
                    # Start new chapter
                    chapter_number += 1
                    title = match.group(2).strip() if len(match.groups()) > 1 and match.group(2) else f"Ch∆∞∆°ng {match.group(1)}"
                    current_chapter = {
                        'number': chapter_number,
                        'title': title
                    }
                    current_content = []
                    is_chapter_header = True
                    in_chapter_content = True
                    break
            
            if not is_chapter_header and in_chapter_content and current_chapter:
                current_content.append(line)
        
        # Add last chapter
        if current_chapter and current_content:
            chapters.append({
                'number': current_chapter['number'],
                'title': current_chapter['title'],
                'content': '\n'.join(current_content).strip(),
                'chapter_id': f'{current_chapter["number"]:03d}'
            })
        
        self.log(f"üîç ƒê√£ b·ªè qua {content_start_idx} d√≤ng m·ª•c l·ª•c/header")
        self.log(f"üìä T√¨m th·∫•y {len(chapters)} ch∆∞∆°ng th·∫≠t")
        
        return chapters
    
    def open_output_folder(self):
        """M·ªü th∆∞ m·ª•c output"""
        output_dir = self.output_dir_var.get()
        if not os.path.exists(output_dir):
            os.makedirs(output_dir, exist_ok=True)
        os.startfile(output_dir)
    
    def log(self, message):
        """Th√™m message v√†o log"""
        import time
        timestamp = time.strftime("%H:%M:%S")
        log_message = f"[{timestamp}] {message}\n"
        self.log_text.insert(tk.END, log_message)
        self.log_text.see(tk.END)
        self.root.update()

def main():
    """Main function"""
    root = tk.Tk()
    app = TxtToEpubConverter(root)
    root.mainloop()

if __name__ == "__main__":
    main()
